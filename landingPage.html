<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Letters</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
            height: 100vh; /* Set height to viewport height */
            background-color: #e9e9e9; /* Updated background color */
            position: relative;
        }
        .letter {
            font-size: 150px; /* Increased font size */
            position: absolute;
            color: #333;
            transition: transform 0.1s, color 0.3s, font-family 0.3s, font-weight 0.3s;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <script>
        const text = 'tjark j. schade';
        const letters = text.split('');
        const body = document.body;
        const width = window.innerWidth;
        const height = window.innerHeight;
        const margin = 50; // Margin from edges

        // Initial positions for "tjark j. schade" with some randomness
        const initialPositions = {
            't': { left: 150, top: 150 },
            'j': { left: 250, top: 150 },
            'a': { left: 350, top: 150 },
            'r': { left: 450, top: 150 },
            'k': { left: 550, top: 150 },
            ' ': { left: 650, top: 150 }, // Space between words
            'j': { left: 750, top: 150 },
            '.': { left: 850, top: 150 },
            's': { left: 950, top: 150 },
            'c': { left: 1050, top: 150 },
            'h': { left: 1150, top: 150 },
            'a': { left: 1250, top: 150 },
            'd': { left: 1350, top: 150 },
            'e': { left: 1450, top: 150 }
        };

        // Random properties for letters
        function getRandomProperties() {
            const colors = [
                'black',
                'rgb(0, 0, 255)',
                'rgb(50, 220, 0)',
                'rgb(230, 70, 220)',
                'rgb(255, 115, 70)'
            ];
            const fontFamilies = ['sans-serif', 'serif'];
            const fontWeights = ['normal', 'bold'];

            return {
                color: Math.random() < 0.6 ? 'black' : colors[Math.floor(Math.random() * colors.length)],
                fontFamily: Math.random() < 0.7 ? 'sans-serif' : 'serif',
                fontWeight: fontWeights[Math.floor(Math.random() * fontWeights.length)]
            };
        }

        // Store initial positions and states
        const letterElements = letters.map((letter) => {
            const span = document.createElement('span');
            span.textContent = letter;
            span.className = 'letter';

            // Apply random styles
            const { color, fontFamily, fontWeight } = getRandomProperties();
            span.style.color = color;
            span.style.fontFamily = fontFamily;
            span.style.fontWeight = fontWeight;

            // Position letters initially close to spelling out the text with randomness
            const basePosition = initialPositions[letter] || { left: Math.random() * (width - 2 * margin) + margin, top: Math.random() * (height - 2 * margin) + margin };
            const initialLeft = basePosition.left + (Math.random() - 0.5) * 50; // Reduced randomness
            const initialTop = basePosition.top + (Math.random() - 0.5) * 50;  // Reduced randomness
            span.style.left = `${Math.max(margin, Math.min(initialLeft, width - margin))}px`;
            span.style.top = `${Math.max(margin, Math.min(initialTop, height - margin))}px`;

            // Initialize rotation to 0 degrees
            span.dataset.rotation = 0;

            // Random speed and rotation values
            span.dataset.speedX = (Math.random() * 2 - 1) * 0.1; // Adjusted movement speed
            span.dataset.speedY = (Math.random() * 2 - 1) * 0.1; // Adjusted movement speed
            span.dataset.rotationSpeed = (Math.random() * 2 - 1) * 0.02; // Adjusted rotation speed

            // Add event listener for clicks
            span.addEventListener('click', () => {
                // Ensure at least one characteristic changes
                const properties = ['color', 'fontFamily', 'fontWeight'];
                let changed = false;

                properties.forEach(property => {
                    if (Math.random() > 0.5 || !changed) { // Ensure at least one change
                        changed = true;
                        switch (property) {
                            case 'color':
                                const colors = [
                                    'black',
                                    'rgb(0, 0, 255)',
                                    'rgb(50, 220, 0)',
                                    'rgb(230, 70, 220)',
                                    'rgb(255, 115, 70)'
                                ];
                                span.style.color = colors[Math.floor(Math.random() * colors.length)];
                                break;
                            case 'fontFamily':
                                span.style.fontFamily = Math.random() < 0.7 ? 'sans-serif' : 'serif';
                                break;
                            case 'fontWeight':
                                span.style.fontWeight = span.style.fontWeight === 'bold' ? 'normal' : 'bold';
                                break;
                        }
                    }
                });

                // Add bounce effect on click
                const bounceDuration = 1500; // Duration in milliseconds
                const bounceSpeed = 1.5; // Speed factor

                // Store the original position
                const startLeft = parseFloat(span.style.left);
                const startTop = parseFloat(span.style.top);
                let bounceStartTime = Date.now();
                let isBouncing = true;

                function bounce() {
                    const elapsed = Date.now() - bounceStartTime;
                    if (elapsed < bounceDuration) {
                        const progress = elapsed / bounceDuration;
                        const easing = Math.sin(progress * Math.PI / 2); // Smooth in-out effect
                        span.style.left = `${startLeft + (Math.random() * 2 - 1) * bounceSpeed * easing}px`;
                        span.style.top = `${startTop + (Math.random() * 2 - 1) * bounceSpeed * easing}px`;
                        requestAnimationFrame(bounce);
                    } else {
                        isBouncing = false;
                    }
                }

                bounce();

                // Keep bouncing as long as the letter is clicked
                span.addEventListener('mousedown', () => {
                    isBouncing = true;
                    bounceStartTime = Date.now();
                    bounce();
                });

                document.addEventListener('mouseup', () => {
                    isBouncing = false;
                });
            });

            body.appendChild(span);
            return span;
        });

        function moveLetters(deltaY, speedFactor) {
            letterElements.forEach(letter => {
                let speedX = parseFloat(letter.dataset.speedX);
                let speedY = parseFloat(letter.dataset.speedY);
                let rotationSpeed = parseFloat(letter.dataset.rotationSpeed);
                let left = parseFloat(letter.style.left);
                let top = parseFloat(letter.style.top);

                // Update rotation based on scroll
                let currentRotation = parseFloat(letter.dataset.rotation);
                currentRotation += rotationSpeed;
                letter.dataset.rotation = currentRotation;
                letter.style.transform = `rotate(${currentRotation}deg)`;

                // Adjust movement based on scroll delta and speed factor
                const movementSpeed = 1 + speedFactor * 10; // Reset speed factor
                left += (speedX * deltaY * movementSpeed);
                top += (speedY * deltaY * movementSpeed);

                // Bounce off the borders with additional margin
                if (left < margin || left > width - margin) {
                    speedX = -speedX;
                    letter.dataset.speedX = speedX;
                }
                if (top < margin || top > height - margin) {
                    speedY = -speedY;
                    letter.dataset.speedY = speedY;
                }

                // Ensure letters stay within bounds
                left = Math.max(margin, Math.min(left, width - margin));
                top = Math.max(margin, Math.min(top, height - margin));

                letter.style.left = left + 'px';
                letter.style.top = top + 'px';
            });

            // Check for collisions between letters
            checkCollisions();
        }

        function continuousMovement() {
            letterElements.forEach(letter => {
                let speedX = parseFloat(letter.dataset.speedX);
                let speedY = parseFloat(letter.dataset.speedY);
                let rotationSpeed = parseFloat(letter.dataset.rotationSpeed);
                let left = parseFloat(letter.style.left);
                let top = parseFloat(letter.style.top);

                // Update rotation
                let currentRotation = parseFloat(letter.dataset.rotation);
                currentRotation += rotationSpeed;
                letter.dataset.rotation = currentRotation;
                letter.style.transform = `rotate(${currentRotation}deg)`;

                // Adjust movement
                const movementSpeed = 0.1; // Reduced movement speed when not scrolling
                left += speedX * movementSpeed;
                top += speedY * movementSpeed;

                // Bounce off the borders with additional margin
                if (left < margin || left > width - margin) {
                    speedX = -speedX;
                    letter.dataset.speedX = speedX;
                }
                if (top < margin || top > height - margin) {
                    speedY = -speedY;
                    letter.dataset.speedY = speedY;
                }

                // Ensure letters stay within bounds
                left = Math.max(margin, Math.min(left, width - margin));
                top = Math.max(margin, Math.min(top, height - margin));

                letter.style.left = left + 'px';
                letter.style.top = top + 'px';
            });

            // Check for collisions between letters
            checkCollisions();
            requestAnimationFrame(continuousMovement);
        }

        function checkCollisions() {
            for (let i = 0; i < letterElements.length; i++) {
                for (let j = i + 1; j < letterElements.length; j++) {
                    const letterA = letterElements[i];
                    const letterB = letterElements[j];
                    const rectA = letterA.getBoundingClientRect();
                    const rectB = letterB.getBoundingClientRect();

                    if (rectA.left < rectB.right &&
                        rectA.right > rectB.left &&
                        rectA.top < rectB.bottom &&
                        rectA.bottom > rectB.top) {
                        // Collision detected, bounce letters off each other
                        const speedAX = parseFloat(letterA.dataset.speedX);
                        const speedAY = parseFloat(letterA.dataset.speedY);
                        const speedBX = parseFloat(letterB.dataset.speedX);
                        const speedBY = parseFloat(letterB.dataset.speedY);

                        letterA.dataset.speedX = -speedAX;
                        letterA.dataset.speedY = -speedAY;
                        letterB.dataset.speedX = -speedBX;
                        letterB.dataset.speedY = -speedBY;
                    }
                }
            }
        }

        let scrolling = false;
        let scrollDelta = 0;
        let transitionSpeed = 0.05; // Easing speed factor

        function onScroll(event) {
            scrolling = true;
            scrollDelta = event.deltaY;

            // Move letters based on scroll
            moveLetters(scrollDelta, 1); // Reset speed factor

            clearTimeout(window.scrollTimeout);
            window.scrollTimeout = setTimeout(() => {
                scrolling = false;
            }, 500); // Delay for smoothing transition
        }

        window.addEventListener('wheel', onScroll);

        function animate() {
            if (scrolling) {
                // Easing between scrolling and non-scrolling
                letterElements.forEach(letter => {
                    let currentSpeedX = parseFloat(letter.dataset.speedX);
                    let currentSpeedY = parseFloat(letter.dataset.speedY);
                    letter.dataset.speedX = currentSpeedX + (currentSpeedX - currentSpeedX) * transitionSpeed;
                    letter.dataset.speedY = currentSpeedY + (currentSpeedY - currentSpeedY) * transitionSpeed;
                });
                requestAnimationFrame(animate);
            } else {
                // Continue movement when not scrolling but slower
                requestAnimationFrame(continuousMovement);
            }
        }

        animate();
    </script>
</body>
</html>
