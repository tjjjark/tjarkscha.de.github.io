<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tjarkscha.de</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
            height: 100vh; /* Set height to viewport height */
            background-color: #e9e9e9; /* Updated background color */
            position: relative;
            touch-action: none; /* Prevent default touch actions like scrolling */
        }
        .letter {
            font-size: 18vw; /* Responsive font size based on viewport width */
            position: absolute;
            color: #333;
            transition: transform 0.1s, color 0.1s, font-family 0.1s, font-weight 0.1s;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <script>
        const text = 'tjark j. schade';
        const letters = text.split('');
        const body = document.body;
        const width = window.innerWidth;
        const height = window.innerHeight;
        const margin = 50; // Margin from edges

        // B-Spline curve generation
        function bSpline(t, points) {
            const n = points.length - 1;
            const p = 3; // Degree of the B-Spline
            const k = Math.floor(t * (n - p + 1));
            const localT = t * (n - p + 1) - k;
            const t0 = k / (n - p + 1);
            const t1 = t0 + 1;

            const basis = (t, k, p) => {
                if (p === 0) return (k <= t && t < k + 1) ? 1 : 0;
                const a = (t - k) / p;
                const b = (k + p + 1 - t) / p;
                return a * basis(t, k, p - 1) + b * basis(t, k + 1, p - 1);
            };

            return [
                basis(localT, k, p) * points[k][0] + basis(localT, k + 1, p) * points[k + 1][0],
                basis(localT, k, p) * points[k][1] + basis(localT, k + 1, p) * points[k + 1][1]
            ];
        }

        function generateBSplinePoints(controlPoints, numPoints) {
            const points = [];
            for (let i = 0; i <= 1; i += 1 / (numPoints - 1)) {
                points.push(bSpline(i, controlPoints));
            }
            return points;
        }

        // Define control points for B-Spline expanded across the screen
        const controlPoints = [
            [margin, margin],
            [width / 6, height / 4],
            [width / 3, height / 2],
            [2 * width / 3, 2 * height / 3],
            [5 * width / 6, height / 4],
            [width - margin, height - margin]
        ];

        const numPoints = 15; // Total number of points along the spline
        const splinePoints = generateBSplinePoints(controlPoints, numPoints);

        // Initial positions for letters along the spline
        const initialPositions = {};
        letters.forEach((letter, index) => {
            initialPositions[letter] = splinePoints[index % numPoints] || [Math.random() * (width - 2 * margin) + margin, Math.random() * (height - 2 * margin) + margin];
        });

        // Random properties for letters
        function getRandomProperties() {
            const colors = [
                'black',
                'rgb(0, 0, 255)',
                'rgb(50, 220, 0)',
                'rgb(230, 70, 220)',
                'rgb(255, 115, 70)'
            ];
            const fontFamilies = ['sans-serif', 'serif'];
            const fontWeights = ['normal', 'bold'];

            return {
                color: Math.random() < 0.7 ? 'black' : colors[Math.floor(Math.random() * colors.length)],
                fontFamily: Math.random() < 0.7 ? 'sans-serif' : 'serif',
                fontWeight: fontWeights[Math.floor(Math.random() * fontWeights.length)]
            };
        }

        // Store initial positions and states
        const letterElements = letters.map((letter) => {
            const span = document.createElement('span');
            span.textContent = letter;
            span.className = 'letter';

            // Apply random styles
            const { color, fontFamily, fontWeight } = getRandomProperties();
            span.style.color = color;
            span.style.fontFamily = fontFamily;
            span.style.fontWeight = fontWeight;

            // Position letters initially along the spline
            const [initialLeft, initialTop] = initialPositions[letter] || [Math.random() * (width - 2 * margin) + margin, Math.random() * (height - 2 * margin) + margin];
            span.style.left = `${Math.max(margin, Math.min(initialLeft, width - margin))}px`;
            span.style.top = `${Math.max(margin, Math.min(initialTop, height - margin))}px`;

            // Initialize rotation to 0 degrees
            span.dataset.rotation = 0;

            // Random speed and rotation values
            span.dataset.speedX = (Math.random() * 2 - 1) * 0.2; // Adjusted movement speed
            span.dataset.speedY = (Math.random() * 2 - 1) * 0.2; // Adjusted movement speed
            span.dataset.rotationSpeed = (Math.random() * 2 - 1) * 0.05; // Adjusted rotation speed

            // Add event listener for clicks
            span.addEventListener('click', () => {
                // Ensure at least one characteristic changes
                const properties = ['color', 'fontFamily', 'fontWeight'];
                let changed = false;

                properties.forEach(property => {
                    if (Math.random() > 0.5 || !changed) { // Ensure at least one change
                        changed = true;
                        switch (property) {
                            case 'color':
                                const colors = [
                                    'black',
                                    'rgb(0, 0, 255)',
                                    'rgb(50, 220, 0)',
                                    'rgb(230, 70, 220)',
                                    'rgb(255, 115, 70)'
                                ];
                                span.style.color = colors[Math.floor(Math.random() * colors.length)];
                                break;
                            case 'fontFamily':
                                span.style.fontFamily = Math.random() < 0.7 ? 'sans-serif' : 'serif';
                                break;
                            case 'fontWeight':
                                span.style.fontWeight = span.style.fontWeight === 'bold' ? 'normal' : 'bold';
                                break;
                        }
                    }
                });
            });

            body.appendChild(span);
            return span;
        });

        function moveLetters(deltaY) {
            letterElements.forEach(letter => {
                let speedX = parseFloat(letter.dataset.speedX);
                let speedY = parseFloat(letter.dataset.speedY);
                let rotationSpeed = parseFloat(letter.dataset.rotationSpeed);
                let left = parseFloat(letter.style.left);
                let top = parseFloat(letter.style.top);

                // Update rotation based on scroll
                let currentRotation = parseFloat(letter.dataset.rotation);
                currentRotation += rotationSpeed;
                letter.dataset.rotation = currentRotation;
                letter.style.transform = `rotate(${currentRotation}deg)`;

                // Adjust movement based on scroll delta
                const movementSpeed = 0.5; // Movement speed during scroll
                left += (speedX * deltaY * movementSpeed);
                top += (speedY * deltaY * movementSpeed);

                // Bounce off the borders with additional margin
                if (left < margin || left > width - margin) {
                    speedX = -speedX;
                    letter.dataset.speedX = speedX;
                }
                if (top < margin || top > height - margin) {
                    speedY = -speedY;
                    letter.dataset.speedY = speedY;
                }

                // Ensure letters stay within bounds
                left = Math.max(margin, Math.min(left, width - margin));
                top = Math.max(margin, Math.min(top, height - margin));

                letter.style.left = left + 'px';
                letter.style.top = top + 'px';
            });

            // Request next animation frame
            requestAnimationFrame(() => moveLetters(deltaY));
        }

        function continuousMovement() {
            letterElements.forEach(letter => {
                let speedX = parseFloat(letter.dataset.speedX);
                let speedY = parseFloat(letter.dataset.speedY);
                let rotationSpeed = parseFloat(letter.dataset.rotationSpeed);
                let left = parseFloat(letter.style.left);
                let top = parseFloat(letter.style.top);

                // Update rotation
                let currentRotation = parseFloat(letter.dataset.rotation);
                currentRotation += rotationSpeed;
                letter.dataset.rotation = currentRotation;
                letter.style.transform = `rotate(${currentRotation}deg)`;

                // Adjust movement
                const movementSpeed = 3; // Increased movement speed when not scrolling
                left += speedX * movementSpeed;
                top += speedY * movementSpeed;

                // Bounce off the borders with additional margin
                if (left < margin || left > width - margin) {
                    speedX = -speedX;
                    letter.dataset.speedX = speedX;
                }
                if (top < margin || top > height - margin) {
                    speedY = -speedY;
                    letter.dataset.speedY = speedY;
                }

                // Ensure letters stay within bounds
                left = Math.max(margin, Math.min(left, width - margin));
                top = Math.max(margin, Math.min(top, height - margin));

                letter.style.left = left + 'px';
                letter.style.top = top + 'px';
            });

            // Request next animation frame
            requestAnimationFrame(continuousMovement);
        }

        let scrolling = false;
        let scrollDelta = 0;
        let transitionSpeed = 0.05; // Easing speed factor

        function onScroll(event) {
            scrolling = true;
            scrollDelta = event.deltaY;

            // Move letters based on scroll
            moveLetters(scrollDelta);

            clearTimeout(window.scrollTimeout);
            window.scrollTimeout = setTimeout(() => {
                scrolling = false;
            }, 500); // Delay for smoothing transition
        }

        // Add both wheel and touch event listeners
        window.addEventListener('wheel', onScroll);
        window.addEventListener('touchmove', (event) => {
            // Prevent default touch actions
            event.preventDefault();

            // Calculate deltaY for touch events
            const deltaY = event.touches[0].clientY - (lastTouchY || event.touches[0].clientY);
            lastTouchY = event.touches[0].clientY;
            onScroll({ deltaY });
        });

        let lastTouchY = 0;

        function animate() {
            if (scrolling) {
                // Easing between scrolling and non-scrolling
                letterElements.forEach(letter => {
                    let currentSpeedX = parseFloat(letter.dataset.speedX);
                    let currentSpeedY = parseFloat(letter.dataset.speedY);
                    letter.dataset.speedX = currentSpeedX + (currentSpeedX - currentSpeedX) * transitionSpeed;
                    letter.dataset.speedY = currentSpeedY + (currentSpeedY - currentSpeedY) * transitionSpeed;
                });
                requestAnimationFrame(animate);
            } else {
                // Continue movement when not scrolling but faster
                requestAnimationFrame(continuousMovement);
            }
        }

        animate();
    </script>
</body>
</html>
